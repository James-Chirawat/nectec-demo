import streamlit as st
import pandas as pd
import json
import os
import plotly.express as px

st.set_page_config(page_title="Data & Ingestion Dashboard", layout="wide")

st.title("ðŸ“Š Data & Ingestion Dashboard")

# Load analysis results
analysis_file = 'data/analysis_results.json'
if os.path.exists(analysis_file):
    with open(analysis_file, 'r') as f:
        full_analysis_data = json.load(f)
        analysis_data = full_analysis_data.get('basic_eda', {})
        target_data = full_analysis_data.get('target_analysis', {})
else:
    st.error("Analysis results not found. Please run ingest.py and analyze.py first.")
    st.stop()

# Main navigation
app_mode = st.sidebar.radio("Navigate", ["Tables Overview", "Advanced Insights", "Customer Segmentation", "Predictive Analytics"])

if app_mode == "Tables Overview":
    # Sidebar for table selection
    tables = list(analysis_data.keys())
    selected_table = st.sidebar.selectbox("Select Table", tables)

    if selected_table:
        st.header(f"Table: {selected_table}")
        
        # Tabs for different views
        tab1, tab2, tab3 = st.tabs(["Overview", "Metadata", "Data Preview"])
        
        with tab1:
            st.subheader("Statistical Summary")
            col1, col2 = st.columns(2)
            
            table_stats = analysis_data[selected_table]
            col1.metric("Row Count", table_stats['row_count'])
            col2.metric("Column Count", table_stats['column_count'])
            
            # Missing values
            if any(table_stats['missing_values'].values()):
                st.write("### Missing Values")
                missing_df = pd.DataFrame(table_stats['missing_values'].items(), columns=['Column', 'Missing Count'])
                fig = px.bar(missing_df, x='Column', y='Missing Count', title="Missing Values per Column")
                st.plotly_chart(fig)
            else:
                st.success("No missing values found!")
                
            # Numeric Summary
            if table_stats['numeric_summary'] != "No numeric columns":
                st.write("### Numeric Columns Description")
                st.write(pd.DataFrame(table_stats['numeric_summary']))
                
        with tab2:
            st.subheader("Metadata Information")
            # Load specific metadata file
            metadata_file = f'data/metadata/{selected_table}_metadata.json'
            if os.path.exists(metadata_file):
                with open(metadata_file, 'r') as f:
                    meta = json.load(f)
                
                st.write("#### Column Definitions")
                st.table(pd.DataFrame(meta['column_info']))
            else:
                st.warning("Metadata file not found.")
                
        with tab3:
            st.subheader("Data Sample")
            landing_file = f'data/landing/{selected_table}.csv'
            if os.path.exists(landing_file):
                df = pd.read_csv(landing_file)
                st.dataframe(df.head(100))
            else:
                st.error("Landing data file not found.")

elif app_mode == "Advanced Insights":
    st.header("ðŸš€ Advanced Insights")
    
    # 1. Top 5 Albums
    st.subheader("Top 5 Albums by Value")
    if "top_albums" in target_data:
        df_albums = pd.DataFrame(target_data["top_albums"])
        fig_albums = px.bar(df_albums, x='title', y='album_value', color='album_value',
                           title="Top 5 Albums (Sum of Track Unit Prices)")
        st.plotly_chart(fig_albums, use_container_width=True)
        st.table(df_albums)
        
    # 2. Revenue by Country
    st.subheader("Revenue by Country")
    if "revenue_by_country" in target_data:
        df_rev = pd.DataFrame(target_data["revenue_by_country"])
        fig_rev = px.pie(df_rev, values='total_revenue', names='billing_country', 
                        title="Revenue Distribution by Country")
        st.plotly_chart(fig_rev, use_container_width=True)
        st.table(df_rev)
        
    # 3. Employee Hierarchy
    st.subheader("Employee Hierarchy")
    if "employee_hierarchy" in target_data:
        df_emp = pd.DataFrame(target_data["employee_hierarchy"])
        st.write("Organizational Reporting Structure:")
        st.table(df_emp)

elif app_mode == "Customer Segmentation":
    st.header("ðŸ‘¥ Customer Segmentation (K-Means)")
    
    if "customer_clusters" in target_data:
        df_clusters = pd.DataFrame(target_data["customer_clusters"])
        
        st.write("""
        This analysis uses **K-Means Clustering** to segment customers into 3 groups based on their purchasing behavior:
        - **Total Invoices**: Number of distinct purchases.
        - **Total Spent**: Total revenue generated by the customer.
        """)
        
        # Plotly Scatter Plot
        fig_clusters = px.scatter(
            df_clusters, 
            x='total_invoices', 
            y='total_spent', 
            color=df_clusters['cluster'].astype(str),
            hover_data=['customer_id'],
            labels={'color': 'Cluster', 'total_invoices': 'Number of Invoices', 'total_spent': 'Total Spent ($)'},
            title="Customer Segments: Frequency vs. Monetary Value"
        )
        st.plotly_chart(fig_clusters, use_container_width=True)
        
        # Summary table per cluster
        st.subheader("Cluster Summary")
        summary = df_clusters.groupby('cluster').agg({
            'customer_id': 'count',
            'total_invoices': 'mean',
            'total_spent': 'mean'
        }).rename(columns={'customer_id': 'Customer Count', 'total_invoices': 'Avg Invoices', 'total_spent': 'Avg Spent'})
        st.write(summary)
        
        st.subheader("Customer Details")
        st.dataframe(df_clusters)
    else:
        st.warning("Customer clustering data not found. Please run analyze.py.")

elif app_mode == "Predictive Analytics":
    st.header("ðŸ”® Predictive Analytics (LightGBM)")
    
    if "prediction_results" in target_data:
        pred_res = target_data["prediction_results"]
        
        col1, col2 = st.columns(2)
        col1.metric("RÂ² Score", f"{pred_res['r2_score']:.4f}")
        col2.metric("Mean Squared Error", f"{pred_res['mse']:.2f}")
        
        # Feature Importance
        st.subheader("Feature Importance")
        feat_imp = pd.DataFrame(pred_res['feature_importance'].items(), columns=['Feature', 'Importance']).sort_values('Importance', ascending=False)
        fig_imp = px.bar(feat_imp, x='Importance', y='Feature', orientation='h', title="LightGBM Feature Importance")
        st.plotly_chart(fig_imp, use_container_width=True)
        
        # Actual vs Predicted
        st.subheader("Actual vs. Predicted Spending")
        df_avp = pd.DataFrame(pred_res['actual_vs_pred'])
        fig_avp = px.scatter(df_avp, x='actual', y='predicted', 
                            labels={'actual': 'Actual Spending ($)', 'predicted': 'Predicted Spending ($)'},
                            title="Actual vs. Predicted Values")
        # Add a 45-degree line for reference
        min_val = min(df_avp['actual'].min(), df_avp['predicted'].min())
        max_val = max(df_avp['actual'].max(), df_avp['predicted'].max())
        fig_avp.add_shape(type="line", x0=min_val, y0=min_val, x1=max_val, y1=max_val, line=dict(color="Red", dash="dash"))
        st.plotly_chart(fig_avp, use_container_width=True)
        
    else:
        st.warning("Prediction data not found. Please run analyze.py.")




st.sidebar.markdown("---")
st.sidebar.info("This dashboard displays data ingested from PostgreSQL and analyzed automatically.")
